import os
import copy
import subprocess
from .keyfiles import KeyFiles
from . import utils
from . import server

from sanic.log import logger


def bsp_tools_path(soctype: str, bspversion: str) -> str:
    suffix = 'tegra186' if soctype == 'tegra194' else soctype
    toolspath = os.path.join(server.config_get('L4T_TOOLS_BASE'),
                             'L4T-{}-{}'.format(bspversion, suffix),
                             'Linux_for_Tegra')
    return toolspath if os.path.exists(toolspath) else None


class TegraSigner:
    SCRIPT_SYMLINKS = ['tegraflash.py', 'tegraflash_internal.py', 'BUP_generator.py',
                       os.path.join('rollback', 'rollback_parser.py')]
    V2_SCRIPT_SYMLINKS = ['tegrasign_v3.py', 'tegrasign_v3_internal.py', 'tegrasign_v3_util.py']

    def __init__(self, machine: str, soctype: str, bspversion: str, version: int, workdir: str):
        if soctype not in ['tegra186', 'tegra194', 'tegra210']:
            raise ValueError("soctype '{}' invalid".format(soctype))
        self.version = version
        self.soctype = soctype
        self.machine = machine
        self.workdir = workdir
        self.toolspath = bsp_tools_path(soctype, bspversion)
        if self.toolspath is None:
            raise ValueError("no tools available for soctype={} bspversion={}".format(soctype, bspversion))
        self.keys = KeyFiles('tegrasign', machine)
        bspmajor, bspminor = bspversion.split('.')[0:2]
        self.encrypted_kernel = int(bspmajor) > 32 or (int(bspmajor) == 32 and int(bspminor) >= 5)
        self.script_symlinks = self.SCRIPT_SYMLINKS
        if self.version > 1:
            self.script_symlinks += self.V2_SCRIPT_SYMLINKS

    def _symlink_scripts(self):
        self._remove_scripts()
        for script in self.script_symlinks:
            subdir = os.path.dirname(script)
            if subdir:
                os.makedirs(os.path.join(self.workdir, subdir), exist_ok=True)
            src = os.path.join(self.toolspath, script)
            dest = os.path.join(self.workdir, script)
            if script.endswith('.py') and not (script.startswith('tegraflash') or
                                               script.startswith('tegrasign_v3')):
                with open(os.path.join(self.workdir, script), 'w') as f:
                    f.write('#!/bin/sh\npython2 {} "$@"\n'.format(src))
                os.chmod(dest, 0o755)
            else:
                os.symlink(src, dest)

    def _remove_scripts(self):
        utils.remove_files(self.workdir, [script for script in self.script_symlinks])

    def sign(self, envvars: dict) -> bool:
        env = copy.deepcopy(envvars)
        curpath = os.getenv('PATH')
        env['PATH'] = self.toolspath
        if curpath:
            env['PATH'] += ':' + curpath
        env['MACHINE'] = self.machine
        bupgen = 'BUPGEN' in env
        self._symlink_scripts()
        # We want to return the minimal set of artifacts possible, so
        # make sure we remove:
        # - the files that were sent over
        # - files generated that are not needed:
        #     - tegraflash will sign and encrypt the 'kernel', but cboot does
        #       not boot the encrypted+signed copy, just the signed one (pre-R32.5)
        #     - the subdirectories generated by the signing program
        #     - other housekeeping files
        to_remove = os.listdir(self.workdir) + ['signed', 'encrypted_signed', 'flash.xml.tmp']
        pkc = self.keys.get('rsa_priv.pem')
        if self.soctype == 'tegra210':
            sbk = None
        else:
            to_remove.append('flash.xml')
            if not self.encrypted_kernel:
                kernelname, kernelext = os.path.splitext(env['LNXFILE'])
                to_remove.append(kernelname + '_sigheader' + kernelext + '.encrypt.signed')
            try:
                sbk = self.keys.get('sbk.txt')
            except FileNotFoundError:
                sbk = None
        cmd = ["{}-flash-helper".format(self.soctype),
               '--bup' if bupgen else '--no-flash', '-u', pkc]
        if sbk:
            cmd += ['-v', sbk]
        if self.soctype == 'tegra194':
            cmd += ['flash.xml.in', env['DTBFILE'], '{0}.cfg,{0}-override.cfg'.format(self.machine),
                    env['ODMDATA']]
        else:
            cmd += ['flash.xml.in', env['DTBFILE'], '{}.cfg'.format(self.machine),
                    env['ODMDATA']]

        if self.soctype == 'tegra210':
            cmd.append(env['boardcfg'])
        cmd.append(env['LNXFILE'])
        try:
            logger.info("Running: {}".format(cmd))
            proc = subprocess.run(cmd, stdin=subprocess.DEVNULL, cwd=self.workdir,
                                  env=env, check=True, capture_output=True,
                                  encoding='utf-8')
            self.keys.cleanup()
            logger.debug("stdout: {}".format(proc.stdout))
            logger.debug("stderr: {}".format(proc.stderr))
            # For BUP generation, just return the payloads.
            # For flashing, we return all the signed/encrypted files
            if bupgen:
                utils.remove_files(self.workdir,
                                   [fname for fname in os.listdir(self.workdir) if not fname.startswith('payloads')])
            else:
                utils.remove_files(self.workdir, [fname for fname in to_remove])
            return True
        except subprocess.CalledProcessError as e:
            self.keys.cleanup()
            logger.warning("signing error, stdout: {}\nstderr: {}".format(e.stdout, e.stderr))
        return False

    def signfiles(self, envvars: dict) -> bool:
        env = copy.deepcopy(envvars)
        curpath = os.getenv('PATH')
        env['PATH'] = self.toolspath
        if curpath:
            env['PATH'] += ':' + curpath
        # We want to return the minimal set of artifacts possible.
        # For this method, it's just the '.sig' files generated for the
        # files that were sent over
        files_to_sign = os.listdir(self.workdir)
        keep_files = [f + ".sig" for f in files_to_sign]
        pkc = self.keys.get('rsa_priv.pem')
        self._symlink_scripts()
        cmd = ["tegra-signimage-helper", "--chip 0x{}".format(self.soctype[5:7]), "-u", pkc] + files_to_sign
        try:
            logger.info("Running: {}".format(cmd))
            proc = subprocess.run(cmd, stdin=subprocess.DEVNULL, cwd=self.workdir,
                                  env=env, check=True, capture_output=True,
                                  encoding='utf-8')
            self.keys.cleanup()
            logger.debug("stdout: {}".format(proc.stdout))
            logger.debug("stderr: {}".format(proc.stderr))
            utils.remove_files(self.workdir, [fname for fname in os.listdir(self.workdir)
                                              if fname not in keep_files])
            return True
        except subprocess.CalledProcessError as e:
            self.keys.cleanup()
            logger.warning("signing error, stdout: {}\nstderr: {}".format(e.stdout, e.stderr))
        return False

    def multisign(self, envvars: dict) -> bool:
        env = copy.deepcopy(envvars)
        curpath = os.getenv('PATH')
        env['PATH'] = self.toolspath
        if curpath:
            env['PATH'] += ':' + curpath
        env['MACHINE'] = self.machine
        self._symlink_scripts()
        pkc = self.keys.get('rsa_priv.pem')
        if self.soctype == 'tegra210':
            sbk = None
        else:
            try:
                sbk = self.keys.get('sbk.txt')
            except FileNotFoundError:
                sbk = None
        cmd = ["{}-flash-helper".format(self.soctype), '--bup', '-u', pkc]
        if sbk:
            cmd += ['-v', sbk]
        if self.soctype == 'tegra194':
            cmd += ['flash.xml.in', env['DTBFILE'], '{0}.cfg,{0}-override.cfg'.format(self.machine),
                    env['ODMDATA']]
        else:
            cmd += ['flash.xml.in', env['DTBFILE'], '{}.cfg'.format(self.machine),
                    env['ODMDATA']]
        if self.soctype == 'tegra210':
            cmd.append(env['boardcfg'])
        cmd.append(env['LNXFILE'])
        for spec in env['BUPGENSPECS'].split():
            localenv = copy.deepcopy(env)
            for setting in spec.split(';'):
                var, val = setting.split('=')
                logger.debug('Setting: {}={}'.format(var.upper(), val))
                localenv[var.upper()] = val
            try:
                logger.info("Running: {}".format(cmd))
                proc = subprocess.run(cmd, stdin=subprocess.DEVNULL, cwd=self.workdir,
                                      env=localenv, check=True, capture_output=True,
                                      encoding='utf-8')
                logger.debug("stdout: {}".format(proc.stdout))
                logger.debug("stderr: {}".format(proc.stderr))
            except subprocess.CalledProcessError as e:
                self.keys.cleanup()
                logger.warning("signing error, stdout: {}\nstderr: {}".format(e.stdout, e.stderr))
                return False

        self.keys.cleanup()
        utils.remove_files(self.workdir,
                           [fname for fname in os.listdir(self.workdir) if not fname.startswith('payloads')])
        return True
